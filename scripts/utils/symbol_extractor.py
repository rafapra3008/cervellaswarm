"""Symbol Extractor for Repository Mapping.

This module extracts symbols (functions, classes, types, interfaces) from AST
generated by TreesitterParser. It provides concise signatures without function
bodies, perfect for repository mapping with minimal token usage.

Usage:
    from treesitter_parser import TreesitterParser
    from symbol_extractor import SymbolExtractor

    parser = TreesitterParser()
    extractor = SymbolExtractor(parser)
    symbols = extractor.extract_symbols("app/main.py")

    for symbol in symbols:
        print(f"{symbol.name}: {symbol.signature}")

Supported Languages:
    - Python: functions, classes, type aliases
    - TypeScript/TSX: functions, interfaces, type aliases
    - JavaScript/JSX: functions, classes

Author: Cervella Backend
Version: 1.0.0
Date: 2026-01-19
"""

__version__ = "1.0.0"
__version_date__ = "2026-01-19"

import logging
from dataclasses import dataclass, field
from pathlib import Path
from typing import Any, List, Optional

from tree_sitter import Node
from treesitter_parser import TreesitterParser

# Configure logging
logger = logging.getLogger(__name__)


@dataclass
class Symbol:
    """Represents a code symbol (function, class, interface, etc).

    Attributes:
        name: Symbol name (e.g., "login", "UserService")
        type: Symbol type ("function", "class", "interface", "type")
        file: File path where symbol is defined
        line: Line number where symbol starts
        signature: Concise signature (no function body)
        docstring: Documentation string if available
        references: List of other symbols this symbol references
    """

    name: str
    type: str
    file: str
    line: int
    signature: str
    docstring: str = ""
    references: List[str] = field(default_factory=list)

    def __repr__(self) -> str:
        """String representation for debugging."""
        return f"<Symbol {self.type} '{self.name}' at {self.file}:{self.line}>"


class SymbolExtractor:
    """Extract symbols from source code using tree-sitter.

    This class uses TreesitterParser to parse source files and extract
    symbol definitions (functions, classes, interfaces, types) with their
    signatures but without implementation details.

    Attributes:
        parser: TreesitterParser instance for parsing files
    """

    def __init__(self, parser: TreesitterParser):
        """Initialize extractor with a parser.

        Args:
            parser: TreesitterParser instance to use for parsing
        """
        self.parser = parser
        logger.debug("SymbolExtractor initialized")

    def extract_symbols(self, file_path: str) -> List[Symbol]:
        """Extract all symbols from a file.

        Args:
            file_path: Path to source file

        Returns:
            List of Symbol objects found in the file

        Example:
            >>> extractor = SymbolExtractor(parser)
            >>> symbols = extractor.extract_symbols("app/auth.py")
            >>> print([s.name for s in symbols])
            ['login', 'logout', 'verify_credentials']
        """
        # Parse file
        tree = self.parser.parse_file(file_path)
        if tree is None:
            logger.warning(f"Failed to parse {file_path}, no symbols extracted")
            return []

        # Detect language
        try:
            language = self.parser.detect_language(file_path)
        except ValueError as e:
            logger.warning(f"Cannot extract symbols from {file_path}: {e}")
            return []

        # Extract symbols based on language
        if language == "python":
            return self._extract_python_symbols(tree, file_path)
        elif language in ["typescript", "tsx"]:
            return self._extract_typescript_symbols(tree, file_path)
        elif language in ["javascript", "jsx"]:
            return self._extract_javascript_symbols(tree, file_path)
        else:
            logger.warning(f"Symbol extraction not implemented for: {language}")
            return []

    def _extract_python_symbols(self, tree, file_path: str) -> List[Symbol]:
        """Extract symbols from Python AST using direct traversal.

        Args:
            tree: Parsed tree-sitter Tree
            file_path: Source file path

        Returns:
            List of Symbol objects
        """
        symbols = []

        def traverse(node: Node) -> None:
            """Recursively traverse AST and extract symbols."""
            # Function definitions
            if node.type == "function_definition":
                name_node = node.child_by_field_name("name")
                params_node = node.child_by_field_name("parameters")
                return_node = node.child_by_field_name("return_type")

                if name_node:
                    name = name_node.text.decode()
                    params = params_node.text.decode() if params_node else "()"
                    return_type = (
                        return_node.text.decode() if return_node else ""
                    )

                    # Build signature
                    if return_type:
                        signature = f"def {name}{params} -> {return_type}"
                    else:
                        signature = f"def {name}{params}"

                    # Try to get docstring
                    docstring = ""
                    body = node.child_by_field_name("body")
                    if body and body.child_count > 0:
                        first_stmt = body.children[1] if len(body.children) > 1 else None
                        if first_stmt and first_stmt.type == "expression_statement":
                            string_node = first_stmt.child(0)
                            if string_node and string_node.type == "string":
                                doc_text = string_node.text.decode()
                                docstring = doc_text.strip('"""').strip("'''").strip()

                    symbol = Symbol(
                        name=name,
                        type="function",
                        file=file_path,
                        line=name_node.start_point[0] + 1,
                        signature=signature,
                        docstring=docstring,
                    )
                    symbols.append(symbol)

            # Class definitions
            elif node.type == "class_definition":
                name_node = node.child_by_field_name("name")
                bases_node = node.child_by_field_name("superclasses")

                if name_node:
                    name = name_node.text.decode()
                    bases = bases_node.text.decode() if bases_node else ""

                    # Build signature
                    if bases:
                        signature = f"class {name}{bases}"
                    else:
                        signature = f"class {name}"

                    # Try to get docstring
                    docstring = ""
                    body = node.child_by_field_name("body")
                    if body and body.child_count > 0:
                        first_stmt = body.children[1] if len(body.children) > 1 else None
                        if first_stmt and first_stmt.type == "expression_statement":
                            string_node = first_stmt.child(0)
                            if string_node and string_node.type == "string":
                                doc_text = string_node.text.decode()
                                docstring = doc_text.strip('"""').strip("'''").strip()

                    symbol = Symbol(
                        name=name,
                        type="class",
                        file=file_path,
                        line=name_node.start_point[0] + 1,
                        signature=signature,
                        docstring=docstring,
                    )
                    symbols.append(symbol)

            # Recurse to children
            for child in node.children:
                traverse(child)

        traverse(tree.root_node)
        logger.debug(f"Extracted {len(symbols)} Python symbols from {file_path}")
        return symbols

    def _extract_typescript_symbols(self, tree, file_path: str) -> List[Symbol]:
        """Extract symbols from TypeScript/TSX AST using direct traversal.

        Args:
            tree: Parsed tree-sitter Tree
            file_path: Source file path

        Returns:
            List of Symbol objects
        """
        symbols = []

        def traverse(node: Node) -> None:
            """Recursively traverse AST and extract symbols."""
            # Function declarations
            if node.type == "function_declaration":
                name_node = node.child_by_field_name("name")
                params_node = node.child_by_field_name("parameters")

                if name_node:
                    name = name_node.text.decode()
                    params = params_node.text.decode() if params_node else "()"
                    signature = f"function {name}{params}"

                    symbol = Symbol(
                        name=name,
                        type="function",
                        file=file_path,
                        line=name_node.start_point[0] + 1,
                        signature=signature,
                    )
                    symbols.append(symbol)

            # Interface declarations
            elif node.type == "interface_declaration":
                name_node = node.child_by_field_name("name")
                body_node = node.child_by_field_name("body")

                if name_node:
                    name = name_node.text.decode()
                    body = body_node.text.decode() if body_node else "{ }"

                    # Simplify body if too long
                    if len(body) > 100:
                        body = "{ ... }"

                    signature = f"interface {name} {body}"

                    symbol = Symbol(
                        name=name,
                        type="interface",
                        file=file_path,
                        line=name_node.start_point[0] + 1,
                        signature=signature,
                    )
                    symbols.append(symbol)

            # Type alias declarations
            elif node.type == "type_alias_declaration":
                name_node = node.child_by_field_name("name")

                if name_node:
                    name = name_node.text.decode()
                    signature = f"type {name} = ..."

                    symbol = Symbol(
                        name=name,
                        type="type",
                        file=file_path,
                        line=name_node.start_point[0] + 1,
                        signature=signature,
                    )
                    symbols.append(symbol)

            # Recurse to children
            for child in node.children:
                traverse(child)

        traverse(tree.root_node)
        logger.debug(f"Extracted {len(symbols)} TypeScript symbols from {file_path}")
        return symbols

    def _extract_javascript_symbols(self, tree, file_path: str) -> List[Symbol]:
        """Extract symbols from JavaScript/JSX AST using direct traversal.

        Args:
            tree: Parsed tree-sitter Tree
            file_path: Source file path

        Returns:
            List of Symbol objects
        """
        symbols = []

        def traverse(node: Node) -> None:
            """Recursively traverse AST and extract symbols."""
            # Function declarations
            if node.type == "function_declaration":
                name_node = node.child_by_field_name("name")
                params_node = node.child_by_field_name("parameters")

                if name_node:
                    name = name_node.text.decode()
                    params = params_node.text.decode() if params_node else "()"
                    signature = f"function {name}{params}"

                    symbol = Symbol(
                        name=name,
                        type="function",
                        file=file_path,
                        line=name_node.start_point[0] + 1,
                        signature=signature,
                    )
                    symbols.append(symbol)

            # Class declarations
            elif node.type == "class_declaration":
                name_node = node.child_by_field_name("name")

                if name_node:
                    name = name_node.text.decode()
                    signature = f"class {name}"

                    symbol = Symbol(
                        name=name,
                        type="class",
                        file=file_path,
                        line=name_node.start_point[0] + 1,
                        signature=signature,
                    )
                    symbols.append(symbol)

            # Recurse to children
            for child in node.children:
                traverse(child)

        traverse(tree.root_node)
        logger.debug(f"Extracted {len(symbols)} JavaScript symbols from {file_path}")
        return symbols

    def extract_signature(self, symbol: Symbol) -> str:
        """Extract concise signature from symbol.

        This is already done during symbol creation, so just return
        the stored signature.

        Args:
            symbol: Symbol object

        Returns:
            Concise signature string

        Example:
            >>> symbol = Symbol(name="login", ...)
            >>> extractor.extract_signature(symbol)
            'def login(username: str, password: str) -> bool'
        """
        return symbol.signature

    def extract_references(self, symbol: Symbol, tree) -> List[str]:
        """Extract references (calls to other functions) from symbol.

        This is a simplified implementation. A full implementation would
        analyze the function body to find all called functions.

        Args:
            symbol: Symbol to analyze
            tree: Parsed tree containing the symbol

        Returns:
            List of referenced symbol names
        """
        # NOTE: Reference extraction is a future enhancement (W2.5)
        # Current implementation returns empty list - PageRank works with structure only
        return []


# Convenience function for simple usage
def extract_symbols(file_path: str) -> List[Symbol]:
    """Extract symbols from a file without managing instances.

    This is a convenience function for one-off extraction. For repeated
    extraction, create a SymbolExtractor instance to benefit from caching.

    Args:
        file_path: Path to source file

    Returns:
        List of Symbol objects

    Example:
        >>> from symbol_extractor import extract_symbols
        >>> symbols = extract_symbols("app.py")
        >>> for s in symbols:
        ...     print(s.signature)
    """
    parser = TreesitterParser()
    extractor = SymbolExtractor(parser)
    return extractor.extract_symbols(file_path)


if __name__ == "__main__":
    # Simple CLI for testing
    import sys

    if len(sys.argv) < 2:
        print(f"Usage: python {sys.argv[0]} <file_path>")
        print("\nExtract symbols from a source file")
        sys.exit(1)

    # Enable debug logging
    logging.basicConfig(
        level=logging.DEBUG,
        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    )

    file_path = sys.argv[1]

    try:
        parser = TreesitterParser()
        extractor = SymbolExtractor(parser)
        symbols = extractor.extract_symbols(file_path)

        if symbols:
            print(f"\n✅ Extracted {len(symbols)} symbols from: {file_path}\n")

            # Group by type
            by_type = {}
            for symbol in symbols:
                if symbol.type not in by_type:
                    by_type[symbol.type] = []
                by_type[symbol.type].append(symbol)

            # Display grouped
            for sym_type, type_symbols in sorted(by_type.items()):
                print(f"\n{sym_type.upper()}S ({len(type_symbols)}):")
                for symbol in type_symbols:
                    print(f"  Line {symbol.line:4d}: {symbol.signature}")
                    if symbol.docstring:
                        # Show first line of docstring
                        first_line = symbol.docstring.split("\n")[0]
                        print(f"             # {first_line}")

        else:
            print(f"\n⚠️  No symbols found in: {file_path}")

    except FileNotFoundError:
        print(f"\n❌ File not found: {file_path}")
        sys.exit(1)
    except ValueError as e:
        print(f"\n❌ {e}")
        sys.exit(1)
    except Exception as e:
        print(f"\n❌ Unexpected error: {e}")
        import traceback

        traceback.print_exc()
        sys.exit(1)
